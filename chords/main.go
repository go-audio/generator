package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"time"

	"github.com/go-audio/music/theory"

	"github.com/go-audio/midi"
)

var (
	ppq uint32 = 99
)

func main() {
	f, err := os.Create("output.mid")
	if err != nil {
		log.Fatal(err)
	}

	rand.Seed(int64(time.Now().Nanosecond()))

	enc := midi.NewEncoder(f, midi.SingleTrack, uint16(ppq))
	tr := enc.NewTrack()
	tr.AddAfterDelta(0, midi.CopyrightEvent("Generated by Go-Audio"))

	defer func() {
		tr.AddAfterDelta(0, midi.EndOfTrack())
		if err := enc.Write(); err != nil {
			log.Fatal(err)
		}
		f.Close()
	}()

	// generate a chord progression
	// scale
	scale := theory.MajorScale
	// if t := time.Now().Nanosecond() % 2; t == 0 {
	// 	scale = theory.MelodicMinorScale
	// }

	// random root
	rootInt := rand.Intn(12)

	// Play the scale notes
	root := midi.Notes[rootInt]
	scaleName := fmt.Sprintf("%s %s scale", root, scale)
	fmt.Println(scaleName)
	keys, notes := theory.ScaleNotes(root, scale)
	fmt.Println("Notes in scale:", notes)
	tr.SetName(fmt.Sprintf("%s %v", scaleName, notes))
	octaveBump := 12 * 4
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
	}

	fmt.Println("Chord progression")
	var progression []int
	if scale == theory.MajorScale {
		n := rand.Intn(len(theory.MajorProgressions))
		progression = theory.MajorProgressions[n]
	} else {
		n := rand.Intn(len(theory.MinorProgressions))
		progression = theory.MinorProgressions[n]
	}

	playScale(tr, root, scale)
	playProgression(tr, root, scale, progression)
	// playScaleChords(tr, root, scale)
}

func playScaleChords(tr *midi.Track, root string, scale theory.ScaleName) {
	fmt.Println("Chords in scale")
	var timeBuffer uint32
	keys, _ := theory.ScaleNotes(root, scale)
	octaveBump := 12 * 2

	start := keys[0] + octaveBump
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
		// keep going up
		if keys[i] < start {
			keys[i] += 12
		}
	}

	var firstChord *theory.Chord

	// play all chords in the scale
	for i, _ := range theory.RomanNumerals[scale] {
		chordName := fmt.Sprintf("%s%s\n",
			midi.Notes[keys[i]%12],
			theory.ScaleChords[scale][i])
		fmt.Printf("%s\t%s", theory.RomanNumerals[scale][i], chordName)
		c := theory.NewChordFromAbbrev(chordName)
		if i == 0 {
			firstChord = c
		}

		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}
	}

	// back to the first chord
	for i, k := range firstChord.Keys {
		if i == 0 {
			timeBuffer = ppq * 2
		}
		tr.AddAfterDelta(0, midi.NoteOn(1, k+24, 99))
	}
	for i, k := range firstChord.Keys {
		if i == 0 {
			timeBuffer = ppq * 2
		}
		tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+24))
		if i == 0 {
			timeBuffer = 0
		}
	}
}

func playScale(tr *midi.Track, root string, scale theory.ScaleName) {
	fmt.Printf("Playing scale %s %s\n", root, scale)
	keys, _ := theory.ScaleNotes(root, scale)
	octaveBump := 12 * 4

	start := keys[0] + octaveBump
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
		// keep going up
		if keys[i] < start {
			keys[i] += 12
		}
	}

	for _, k := range keys {
		tr.AddAfterDelta(0, midi.NoteOn(1, k, 99))
		tr.AddAfterDelta(ppq, midi.NoteOff(1, k))
	}

	// back to the first note
	tr.AddAfterDelta(0, midi.NoteOn(1, keys[0]+12, 99))
	tr.AddAfterDelta(ppq, midi.NoteOff(1, keys[0]+12))
}

func playProgression(tr *midi.Track, root string, scale theory.ScaleName, progression []int) {
	var timeBuffer uint32
	octaveBump := 12 * 2
	keys, _ := theory.ScaleNotes(root, scale)
	var c *theory.Chord

	// play the same chord twice
	repeatedChords := func(rate uint32) func() {
		return func() {
			repeats := int((ppq / rate) * 2)
			for n := 0; n < repeats; n++ {
				// note on
				for i, k := range c.Keys {
					tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
					if i == 0 {
						timeBuffer = 0
					}
				}
				// note off
				for i, k := range c.Keys {
					if i == 0 {
						timeBuffer = rate
					}
					tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
					if i == 0 {
						timeBuffer = 0
					}
				}
			}
		}
	}

	// play the same chord twice once at a lower octave then up
	downUp := func(rate uint32) func() {
		return func() {
			repeats := int((ppq / rate) * 4)
			for n := 0; n < repeats; n++ {
				bump := octaveBump + ((n % 2) * 12)
				// note on
				for i, k := range c.Keys {
					if i == 0 {
						k -= 12
					}
					tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+bump, 99))
					if i == 0 {
						timeBuffer = 0
						if n%2 == 0 {
							break
						}
					}
				}
				// note off
				for i, k := range c.Keys {
					if i == 0 {
						timeBuffer = rate
						k -= 12
					}
					tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+bump))
					if i == 0 {
						timeBuffer = 0
						if n%2 == 0 {
							break
						}
					}
				}
			}
		}
	}

	arps := []func(){
		repeatedChords(ppq * 2),
		repeatedChords(ppq),
		downUp(ppq),
		downUp(ppq / 2)}

	for _, fn := range arps {
		for _, k := range progression {
			// testing using triad vs 7th
			var chordType int
			if k%2 == 0 {
				chordType = 1
			}
			chordName := fmt.Sprintf("%s%s\n",
				midi.Notes[keys[k]%12],
				theory.RichScaleChords[scale][k][chordType])

			fmt.Printf("%s\t%s", theory.RomanNumerals[scale][k], chordName)
			c = theory.NewChordFromAbbrev(chordName)
			if c == nil {
				fmt.Println("Couldn't find chord", chordName)
				continue
			}

			fn()
		}
	}
}
