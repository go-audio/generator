package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"time"

	"github.com/go-audio/music/theory"

	"github.com/go-audio/midi"
)

func main() {
	f, err := os.Create("output.mid")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	rand.Seed(int64(time.Now().Nanosecond()))

	var ppq uint32 = 99
	enc := midi.NewEncoder(f, midi.SingleTrack, uint16(ppq))
	tr := enc.NewTrack()
	tr.AddAfterDelta(0, midi.CopyrightEvent("Generated by Go-Audio"))

	// generate a chord progression
	// scale
	scale := theory.MajorScale
	if t := time.Now().Nanosecond() % 2; t == 0 {
		scale = theory.MelodicMinorScale
	}
	var timeBuffer uint32

	// random root
	rootInt := rand.Intn(12)

	// Play the scale notes
	root := midi.Notes[rootInt]
	fmt.Printf("%s %s scale\n", root, scale)
	keys, notes := theory.ScaleNotes(root, scale)
	fmt.Println("Notes in scale:", notes)
	octaveBump := 12 * 4
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
	}

	octaveBump = 12 * 2

	// progressions
	fmt.Println("Chord progression")
	var progression []int
	if scale == theory.MajorScale {
		n := rand.Intn(len(theory.MajorProgressions))
		progression = theory.MajorProgressions[n]
	} else {
		n := rand.Intn(len(theory.MinorProgressions))
		progression = theory.MinorProgressions[n]
	}
	for _, k := range progression {
		chordName := fmt.Sprintf("%s%s\n",
			midi.Notes[keys[k]%12],
			theory.ScaleChords[scale][k])
		fmt.Printf("%s\t%s", theory.RomanNumerals[scale][k], chordName)
		c := theory.NewChordFromAbbrev(chordName)

		// note on
		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		// note off
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}

		// repeat the chord
		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}

	}

	octaveBump = 12 * 2
	for _, k := range keys {
		tr.AddAfterDelta(0, midi.NoteOn(1, k, 99))
		tr.AddAfterDelta(ppq, midi.NoteOff(1, k))
	}
	// back to the first chord
	tr.AddAfterDelta(0, midi.NoteOn(1, keys[0]+12, 99))
	tr.AddAfterDelta(ppq, midi.NoteOff(1, keys[0]+12))

	if leftOver := (len(keys) + 1) % 4; leftOver != 0 {
		emptyQs := 4 - leftOver
		timeBuffer = uint32(emptyQs) * ppq
	}

	fmt.Println("Chords in scale")
	// play all chords in the scale
	for i, _ := range theory.RomanNumerals[scale] {
		chordName := fmt.Sprintf("%s%s\n",
			midi.Notes[keys[i]%12],
			theory.ScaleChords[scale][i])
		fmt.Printf("%s\t%s", theory.RomanNumerals[scale][i], chordName)
		c := theory.NewChordFromAbbrev(chordName)

		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}
	}

	tr.AddAfterDelta(0, midi.EndOfTrack())
	if err := enc.Write(); err != nil {
		log.Fatal(err)
	}
}
