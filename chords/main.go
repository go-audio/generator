package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"
	"time"

	"github.com/go-audio/music/theory"

	"github.com/go-audio/midi"
)

var (
	ppq uint32 = 99
)

func main() {
	f, err := os.Create("output.mid")
	if err != nil {
		log.Fatal(err)
	}

	rand.Seed(int64(time.Now().Nanosecond()))

	enc := midi.NewEncoder(f, midi.SingleTrack, uint16(ppq))
	tr := enc.NewTrack().SetName("Generated")
	tr.AddAfterDelta(0, midi.CopyrightEvent("Generated by Go-Audio"))

	defer func() {
		tr.AddAfterDelta(0, midi.EndOfTrack())
		if err := enc.Write(); err != nil {
			log.Fatal(err)
		}
		f.Close()
	}()

	// generate a chord progression
	// scale
	scale := theory.MajorScale
	if t := time.Now().Nanosecond() % 2; t == 0 {
		scale = theory.MelodicMinorScale
	}

	// random root
	rootInt := rand.Intn(12)

	// Play the scale notes
	root := midi.Notes[rootInt]
	fmt.Printf("%s %s scale\n", root, scale)
	keys, notes := theory.ScaleNotes(root, scale)
	fmt.Println("Notes in scale:", notes)
	octaveBump := 12 * 4
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
	}

	fmt.Println("Chord progression")
	var progression []int
	if scale == theory.MajorScale {
		n := rand.Intn(len(theory.MajorProgressions))
		progression = theory.MajorProgressions[n]
	} else {
		n := rand.Intn(len(theory.MinorProgressions))
		progression = theory.MinorProgressions[n]
	}

	playProgression(tr, root, scale, progression)
	playScale(tr, root, scale)
	playScaleChords(tr, root, scale)
}

func playScaleChords(tr *midi.Track, root string, scale theory.ScaleName) {
	fmt.Println("Chords in scale")
	octaveBump := 12 * 2
	var timeBuffer uint32
	keys, _ := theory.ScaleNotes(root, scale)

	start := keys[0] + octaveBump
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
		// keep going up
		if keys[i] < start {
			keys[i] += 12
		}
	}

	var firstChord *theory.Chord

	// play all chords in the scale
	for i, _ := range theory.RomanNumerals[scale] {
		chordName := fmt.Sprintf("%s%s\n",
			midi.Notes[keys[i]%12],
			theory.ScaleChords[scale][i])
		fmt.Printf("%s\t%s", theory.RomanNumerals[scale][i], chordName)
		c := theory.NewChordFromAbbrev(chordName)
		if i == 0 {
			firstChord = c
		}

		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}
	}

	// back to the first chord
	for i, k := range firstChord.Keys {
		if i == 0 {
			timeBuffer = ppq * 2
		}
		tr.AddAfterDelta(0, midi.NoteOn(1, k+12, 99))
	}
	for i, k := range firstChord.Keys {
		if i == 0 {
			timeBuffer = ppq * 2
		}
		tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+12))
		if i == 0 {
			timeBuffer = 0
		}
	}

}

func playScale(tr *midi.Track, root string, scale theory.ScaleName) {
	fmt.Printf("Playing scale %s %s\n", root, scale)
	keys, _ := theory.ScaleNotes(root, scale)
	octaveBump := 12 * 4

	start := keys[0] + octaveBump
	// move to the 3rd octave
	for i := 0; i < len(keys); i++ {
		keys[i] += octaveBump
		// keep going up
		if keys[i] < start {
			keys[i] += 12
		}
	}

	for _, k := range keys {
		tr.AddAfterDelta(0, midi.NoteOn(1, k, 99))
		tr.AddAfterDelta(ppq, midi.NoteOff(1, k))
	}

	// back to the first note
	tr.AddAfterDelta(0, midi.NoteOn(1, keys[0]+12, 99))
	tr.AddAfterDelta(ppq, midi.NoteOff(1, keys[0]+12))
}

func playProgression(tr *midi.Track, root string, scale theory.ScaleName, progression []int) {
	var timeBuffer uint32
	octaveBump := 12 * 2
	keys, _ := theory.ScaleNotes(root, scale)

	for _, k := range progression {
		// testing using triad vs 7th
		var chordType int
		if k%2 == 0 {
			chordType = 1
		}
		chordName := fmt.Sprintf("%s%s\n",
			midi.Notes[keys[k]%12],
			theory.RichScaleChords[scale][k][chordType])

		fmt.Printf("%s\t%s", theory.RomanNumerals[scale][k], chordName)
		c := theory.NewChordFromAbbrev(chordName)
		if c == nil {
			fmt.Println("Couldn't find chord", chordName)
			continue
		}

		// note on
		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		// note off
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}

		// repeat the chord
		for i, k := range c.Keys {
			tr.AddAfterDelta(timeBuffer, midi.NoteOn(1, k+octaveBump, 99))
			if i == 0 {
				timeBuffer = 0
			}
		}
		for i, k := range c.Keys {
			if i == 0 {
				timeBuffer = ppq * 2
			}
			tr.AddAfterDelta(timeBuffer, midi.NoteOff(1, k+octaveBump))
			if i == 0 {
				timeBuffer = 0
			}
		}

	}
}
